/**
 * 
 */
package com.fengyonggang.brave.druid;

import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.URI;
import java.nio.ByteBuffer;
import java.sql.SQLException;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import com.alibaba.druid.filter.FilterAdapter;
import com.alibaba.druid.filter.FilterChain;
import com.alibaba.druid.pool.DruidDataSource;
import com.alibaba.druid.pool.DruidPooledConnection;
import com.alibaba.druid.proxy.jdbc.CallableStatementProxy;
import com.alibaba.druid.proxy.jdbc.ConnectionProxy;
import com.alibaba.druid.proxy.jdbc.PreparedStatementProxy;
import com.github.kristofa.brave.ClientTracer;
import com.twitter.zipkin.gen.Endpoint;

import zipkin.TraceKeys;

/**
 * @author fengyonggang
 *
 */
public class BraveDruidFilter extends FilterAdapter {

	private static final String URL_PREFIX_ORACLE = "jdbc:oracle";
	private static final String URL_PREFIX_MYSQL = "jdbc:mysql";
	
	private static Map<String, Endpoint> endpointMap = new ConcurrentHashMap<>();
	private ClientTracer tracer;
	
	public BraveDruidFilter(ClientTracer clientTracer) {
		this.tracer = clientTracer;
	}
	
	private boolean isOracle(String url) {
		return url != null && url.startsWith(URL_PREFIX_ORACLE);
	}
	
	private boolean isMysql(String url) {
		return url != null && url.startsWith(URL_PREFIX_MYSQL);
	}
	
	@Override
	public void dataSource_releaseConnection(FilterChain chain, DruidPooledConnection connection) throws SQLException {
		super.dataSource_releaseConnection(chain, connection);
		endTrace();
	}

	@Override
	public DruidPooledConnection dataSource_getConnection(FilterChain chain, DruidDataSource dataSource,
			long maxWaitMillis) throws SQLException {
		
		beginTrace(dataSource.getUrl());
		return super.dataSource_getConnection(chain, dataSource, maxWaitMillis);
	}

	@Override
	public String connection_nativeSQL(FilterChain chain, ConnectionProxy connection, String sql) throws SQLException {
		SqlHolder.addSql(sql);
		return super.connection_nativeSQL(chain, connection, sql);
	}

	@Override
	public CallableStatementProxy connection_prepareCall(FilterChain chain, ConnectionProxy connection, String sql)
			throws SQLException {
		SqlHolder.addSql(sql);
		return super.connection_prepareCall(chain, connection, sql);
	}

	@Override
	public CallableStatementProxy connection_prepareCall(FilterChain chain, ConnectionProxy connection, String sql,
			int resultSetType, int resultSetConcurrency) throws SQLException {
		SqlHolder.addSql(sql);
		return super.connection_prepareCall(chain, connection, sql, resultSetType, resultSetConcurrency);
	}

	@Override
	public CallableStatementProxy connection_prepareCall(FilterChain chain, ConnectionProxy connection, String sql,
			int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
		SqlHolder.addSql(sql);
		return super.connection_prepareCall(chain, connection, sql, resultSetType, resultSetConcurrency, resultSetHoldability);
	}

	@Override
	public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection, String sql)
			throws SQLException {
		SqlHolder.addSql(sql);
		return super.connection_prepareStatement(chain, connection, sql);
	}

	@Override
	public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection, String sql,
			int autoGeneratedKeys) throws SQLException {
		SqlHolder.addSql(sql);
		return super.connection_prepareStatement(chain, connection, sql, autoGeneratedKeys);
	}

	@Override
	public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection, String sql,
			int resultSetType, int resultSetConcurrency) throws SQLException {
		SqlHolder.addSql(sql);
		return super.connection_prepareStatement(chain, connection, sql, resultSetType, resultSetConcurrency);
	}

	@Override
	public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection, String sql,
			int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
		SqlHolder.addSql(sql);
		return super.connection_prepareStatement(chain, connection, sql, resultSetType, resultSetConcurrency,
				resultSetHoldability);
	}

	@Override
	public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection, String sql,
			int[] columnIndexes) throws SQLException {
		SqlHolder.addSql(sql);
		return super.connection_prepareStatement(chain, connection, sql, columnIndexes);
	}

	@Override
	public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection, String sql,
			String[] columnNames) throws SQLException {
		SqlHolder.addSql(sql);
		return super.connection_prepareStatement(chain, connection, sql, columnNames);
	}
	
	private void beginTrace(String url) {
		Endpoint endpoint = null;
		try {
			if (isMysql(url)) {
				endpoint = createMysqlEndpoint(url);
			} else if (isOracle(url)) {
				endpoint = createOracleEndpoint(url);
			} else {
				// not support
			}
		} catch (Exception ignore) {
		}
		
		tracer.startNewSpan("query");
		if(endpoint != null) {
			tracer.setClientSent(endpoint);
		} else {
			tracer.setClientSent();
		}
	}
	
	private void endTrace() {
		Set<String> sqls = SqlHolder.getSql();
		if(sqls != null && sqls.size() > 0) {
			for(String sql : sqls) {
				tracer.submitBinaryAnnotation(TraceKeys.SQL_QUERY, sql);
			}
		}
		tracer.setClientReceived();
		
		SqlHolder.clear();
	}

	private Endpoint createOracleEndpoint(String url) throws Exception {
		String subUrl = url.split("@")[1]; // strip "jdbc:oracle:thin:@"
		String[] arr = subUrl.split(":");
		InetAddress address = Inet4Address.getByName(arr[0]);
		int ipv4 = ByteBuffer.wrap(address.getAddress()).getInt();
		int port = Integer.parseInt(arr[1]);
		String schema = arr[2];
		return createEndpoint(ipv4, port, "oracle-" + schema);
	}

	private Endpoint createMysqlEndpoint(String mysqlUrl) throws Exception {
		URI url = URI.create(mysqlUrl.substring(5)); // strip "jdbc:"
		InetAddress address = Inet4Address.getByName(url.getHost());
		int ipv4 = ByteBuffer.wrap(address.getAddress()).getInt();
		int port = url.getPort() == -1 ? 3306 : url.getPort();

		String serviceName = "mysql";
		String databaseName = url.getPath();
		if (databaseName != null) {
			if(databaseName.startsWith("/")) {
				databaseName = databaseName.substring(1);
			}
			if(!"".equals(databaseName)) {
				serviceName += "-" + databaseName;
			}
		}
		return createEndpoint(ipv4, port, serviceName);
	}

	private Endpoint createEndpoint(int ipv4, int port, String serviceName) {
		String key = serviceName + "-" + ipv4 + "-" + port;
		if (endpointMap.containsKey(key)) {
			return endpointMap.get(key);
		}
		Endpoint endpoint = Endpoint.builder().ipv4(ipv4).port(port).serviceName(serviceName).build();
		endpointMap.put(key, endpoint);
		return endpoint;
	}

	static class SqlHolder {
		private static ThreadLocal<Set<String>> holder = new ThreadLocal<>();

		public static void addSql(String sql) {
			Set<String> sqls = holder.get();
			if (sqls == null) {
				sqls = new HashSet<>();
			}
			sqls.add(sql);
			holder.set(sqls);
		}

		public static Set<String> getSql() {
			return holder.get();
		}

		public static void clear() {
			holder.remove();
		}
	}
}
